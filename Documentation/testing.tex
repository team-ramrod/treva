\section{Testing}

To be able to test and compare the SIMD processor to the normal SISD a program
needed to be written. This program needed to be able to be run with little or no
difference using both either instruction sets.

Two algorithms were thought of that could make use of the SIMD architecture.
The first one is ghosting two images together, the other is to run a fast
Fourier transform. Because the ghosting was very simple to implement and had a
visual output, it was chosen to be implemented first.

\subsection{Ghosting}
  Ghosting two images is where the value of each pixel location of each image is
  added with a 50\% opacity each as shown in figure \ref{ghosting}. To keep the
  process simple the images to be used for testing are single channel eight bit
  grey scale images. These images are first loaded into memory via a Universal
  asynchronous receiver/transmitter (UART) then processed by the CPU,
  then once processed they are sent back to a computer to be viewed via the UART.

  \begin{figure}[h!]
  \caption{An example of a ghosted image}
  \centering
  \includegraphics[width=0.3\textwidth]{images/ghosted}
  \label{ghosting}
  \end{figure}

  The ghosting algorithm process involves two ALU operations, the first one is
  to add the two pixel values, which means they are converted into a 9 bit
  number from the carry. This works fine as the 16bit architecture of Leros can
  store the 9 bit number is a 16 bit register. Then once the pixels have been
  added, the pixel value is divided by two. This has the same effect of giving
  both the images 50\% opacity. To do this divide, a simple right shift is
  applied to the pixel ignoring the least significant bit.

\subsection{Simulation}
 Without the on chip debugging provided by commercial microcontrollers it was
 useful to implement a simulator to test the software that was written to test
 the hardware. With the software correctly passing unit tests in a managed
 environment, the hardware testing and debugging could be done under the
 assumption that the software was correct. This has the potential to saving a lot
 of complication and effort, especially for more involved applications such as
 fourier transforms.

 A simulator was implemented capable of interpreting assembly language,
 simulating the ALU(s) and registers and single stepping through code in a
 manner similar to the gdb debugger.

 Only the external behaviour was mocked, the hardware itself was not due to the
 cost and minimal gains of implementing this. IO was simulated by a queue of
 user specified data elements ready to be fed in each time the 'IN' instruction
 executed. Output from the UART (ie the results of the software) were printed to
 screen and could be checked against a set of expected values for regression
 testing.

 Upon starting the debugger, the user is presented with a prompt at which they
 may run any of the following commands.
 \begin{itemize}
    \item \emph{accumulator} Inspect the value stored in the accumulator register.
    \item \emph{step} Execute the current line and pause execution.
    \item \emph{help} Show this command list.
    \item \emph{breakpoint} Toggle a breakpoint at a specified line.
    \item \emph{continue} Resume execution.
    \item \emph{inspect} Print the value of a specified register.
    \item \emph{dump} Print the accumulator and a specified range of registers.
    \item \emph{print} Print the line-numbered source code.
 \end{itemize}

 The simulator was used to test the ghosting algorithm and quickly diagnosed a
 mistake in the source code.
