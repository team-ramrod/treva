#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-

# Author:
#      Wim Looman
# Copyright:
#      Copyright (c) 2010 Wim Looman

def twos_complement(num,bits=8)
  return num < 0 ? 2**bits + num : num
end

class Operand
  def initialize op
    if op == nil
      @type = nil
    else
      @type, @id, @mod = *op.chars
    end
  end

  def match op
    return {} if @type == nil
    return nil if op == nil

    type, num, mod = *op.chars
    case @type
    when 'a', 'r', 'v'
      return nil if type != @type or mod != @mod
      { @id => Integer(num) }
    when 'm'
      begin
        { 'm' => twos_complement(Integer(op)) }
      rescue ArgumentError
        nil
      end
    end
  end
end

class Opcode
  def initialize opcode
    @chunks = opcode.map do |chunk|
      if chunk[0] <= ?9 && chunk[0] >= ?0
        { :val => chunk.to_i(2), :len => chunk.length }
      else
        { :id => chunk.chars.to_a[0], :len => chunk.chars.to_a[1].to_i }
      end
    end
  end

  def match values
    val = 0
    pos = 16
    @chunks.each do |chunk|
      if chunk.include? :val
        pos -= chunk[:len]
        val += chunk[:val] << pos
      else
        pos -= chunk[:len]
        val += (values[chunk[:id]] & (2**chunk[:len] - 1)) << pos
      end
    end
    return val >> 8, val & 0xFF
  end
end

class Instruction
  def initialize syntax, opcode
    @name, op1, op2 = *syntax
    @op1 = Operand.new(op1)
    @op2 = Operand.new(op2)
    @opcode = opcode
  end

  def match inst
    name, op1, op2 = *inst.split
    return nil unless @name.upcase == name.upcase
    a = @op1.match(op1)
    b = @op2.match(op2)
    return nil unless a != nil and b != nil
    c = @opcode.match(a.merge(b))
    return c
  end

  class << self
    def parse_lines lines
      lines.map { |line| self.parse_line(line) }.compact
    end

    def parse_line line
      chunks = line.split
      return nil unless chunks.length > 3 and chunks.include? ':'
      syntax = []
      syntax << chunks.delete_at(0) while chunks.first != ':'
      chunks.delete_at(0)
      Instruction.new(syntax, Opcode.new(chunks))
    end
  end
end


if !(1..2).include?(ARGV.length) || !File.exist?(ARGV[0])
  puts "Usage: ruby #{$0} <input_file> [<output_file>]"
  exit 1
end

instructions = Instruction.parse_lines(DATA)

input = IO.readlines(ARGV[0])

begin
  instruction = 1
  symbols = {}
  input.each do |line|
    chunks = line.sub(",", " ").split
    case chunks[0]
      when /^#/, /^\/\//, nil
        # Ignore comments and empty lines

      when /^(\w+):/
        symbols[$1] = instruction
        line.sub!(/^\w+:/,"")
        redo

      else
        instruction += 1
    end
  end

  line_no = 0
  instruction = 0
  output = []
  input.map{|a|a.strip.squeeze(' ')}.each do |line|
    line_no += 1
    label = line.sub(",", " ").split[0]
    case label
      when  /^(\w+:)/
        line.sub!($1,"")
        line_no -= 1
        redo
      when /^#/, nil, /^\/\//
        # Ignore comments and blank lines

      else
        instruction += 1
        line.split.each do |chunk|
          if symbols.include? chunk.sub(/^</,'').sub(/^>/,'')
            move_to = symbols[chunk.sub(/^</,'').sub(/^>/,'')]
            case chunk
            when /^</
              val = move_to - 1
            when /^>/
              val = move_to >> 8
            else
              val = move_to - instruction
            end
            line[chunk] = val.to_s
          end
        end
        inst = instructions.find { |inst| inst.match(line) }
        if inst
          inst.match(line).each { |byte| output << byte }
        else
          raise "Unknown instruction [#{line}] near line [#{line_no}]"
        end
    end
  end

rescue RuntimeError => e
  $stderr.puts "There was an error parsing your file:\n\t#{e.message}"
  exit 1
end

case ARGV.length
when 2
  File.open(ARGV[1], "wb") do |file|
    output.each { |char| file.putc(char) }
  end
else
  output.each { |char| $stdout.putc(char) }
end
__END__
  NOP           : 00000 00 0 00000000



  ADD       rx  : 00001 00 0 x8
  SUB       rx  : 00001 10 0 x8
  MULT      rx  : 00001 10 0 x8
  DIV       rx  : 00001 11 0 x8

  ADD       m   : 00001 00 1 m8
  SUB       m   : 00001 10 1 m8
  MULT      rx  : 00001 10 1 x8
  DIV       rx  : 00001 11 1 x8



  AND       rx  : 00100 01 0 x8
  OR        rx  : 00100 10 0 x8
  XOR       rx  : 00100 11 0 x8

  AND       m   : 00100 01 1 m8
  OR        m   : 00100 10 1 m8
  XOR       m   : 00100 11 1 m8



  SHL           : 00010 00 0 00000000
  SHR           : 00010 01 0 00000000
  ROL           : 00010 10 0 00000000
  ROR           : 00010 11 0 00000000



  LOAD      rx  : 00100 00 0 x8
  LOADH     rx  : 00101 00 0 x8
  STORE     rx  : 00110 00 0 x8

  LOAD      m   : 00100 00 1 m8
  LOADH     m   : 00101 00 1 m8



  JAL       rx  : 01000 00 0 x8



  OUT       m   : 00111 00 0 m8
  IN        m   : 00111 10 0 m8



  LOADADDR  rx  : 01010 00 0 x8



  BRANCH    m   : 01001 00 0 m8
  BRZ       m   : 01001 00 1 m8
  BRNZ      m   : 01001 01 0 m8
  BRP       m   : 01001 01 1 m8
  BRN       m   : 01001 10 0 m8



  VADD      vx  : 10001 00 0 x8
  VSUB      vx  : 10001 01 0 x8
  VMULT     vx  : 10001 10 0 x8
  VDIV      vx  : 10001 10 0 x8

  VADD      m   : 10001 00 1 m8
  VSUB      m   : 10001 01 1 m8
  VMULT     vx  : 10001 10 1 x8
  VDIV      vx  : 10001 10 1 x8



  VAND      vx  : 10100 01 0 x8
  VOR       vx  : 10100 10 0 x8
  VXOR      vx  : 10100 11 0 x8



  VSHL          : 10010 00 0 00000000
  VSHR          : 10010 01 0 00000000
  VROL          : 10010 10 0 00000000
  VROR          : 10010 11 0 00000000

  VAND      m   : 10100 01 1 m8
  VOR       m   : 10100 10 1 m8
  VXOR      m   : 10100 11 1 m8
